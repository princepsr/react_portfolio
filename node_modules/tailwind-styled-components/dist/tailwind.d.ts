import React from "react";
declare const isTwElement: unique symbol;
declare type IntrinsicElementsKeys = keyof JSX.IntrinsicElements;
export declare const mergeArrays: (template: TemplateStringsArray, templateElements: (string | undefined | null)[]) => (string | null | undefined)[];
export declare const cleanTemplate: (template: (string | undefined | null)[], inheritedClasses?: string) => string;
declare type StripCallSignature<T> = {
    [K in keyof T]: T[K];
};
export declare type TailwindComponentProps<E extends React.ComponentType<any> | IntrinsicElementsKeys, K extends object> = K extends any ? React.ComponentPropsWithoutRef<E> & React.RefAttributes<React.ComponentRef<E> | undefined> & K : never;
declare type TailwindComponentPropsWith$As<E extends React.ComponentType<any> | IntrinsicElementsKeys, K extends object, As extends IntrinsicElementsKeys | React.ComponentType<any> = E> = TailwindComponentProps<E, K> & InnerTailwindComponentAllProps<As> & {
    $as?: As;
};
export declare type TailwindExoticComponent<E extends React.ComponentType<any> | IntrinsicElementsKeys, K extends object> = StripCallSignature<React.ForwardRefExoticComponent<TailwindComponentProps<E, K>>>;
export interface TailwindComponent<E extends React.ComponentType<any> | IntrinsicElementsKeys, K extends object> extends TailwindExoticComponent<E, K> {
    (props: TailwindComponentProps<E, K> & {
        $as?: never | undefined;
    }): React.ReactElement<TailwindComponentProps<E, K>> | null;
    <As extends IntrinsicElementsKeys | React.ComponentType<any> = E>(props: TailwindComponentPropsWith$As<E, K, As>): React.ReactElement<TailwindComponentPropsWith$As<E, K, As>> | null;
    [isTwElement]: boolean;
}
declare type NoInfer<T> = [T][T extends any ? 0 : never];
export interface TemplateFunction<E extends React.ComponentType<any> | IntrinsicElementsKeys, K2 extends object = {}> {
    <K extends object = {}>(template: TemplateStringsArray, ...templateElements: ((props: NoInfer<React.ComponentPropsWithRef<E> & K2> & K) => string | undefined | null)[]): TailwindComponent<E, K & K2>;
}
declare type InnerTailwindComponent<E extends React.ComponentType<any> | IntrinsicElementsKeys | TailwindComponent<any, any>> = E extends TailwindComponent<infer E2, any> ? E2 : E;
declare type InnerTailwindComponentOtherProps<E extends React.ComponentType<any> | IntrinsicElementsKeys | TailwindComponent<any, any>> = E extends TailwindComponent<any, infer K2> ? K2 : {};
declare type InnerTailwindComponentAllProps<E extends React.ComponentType<any> | IntrinsicElementsKeys | TailwindComponent<any, any>> = E extends TailwindComponent<infer E2, infer K2> ? React.ComponentPropsWithoutRef<E2> & K2 & React.RefAttributes<React.ComponentRef<E2> | undefined> : React.ComponentPropsWithoutRef<E> & React.RefAttributes<React.ComponentRef<E> | undefined>;
export interface TemplateFunctionFactory {
    <E extends TailwindComponent<E2, K2>, E2 extends IntrinsicElementsKeys, K2 extends object = {}>(Element: E): TemplateFunction<E2, K2>;
    <E extends TailwindComponent<any, any>>(Element: E): TemplateFunction<InnerTailwindComponent<E>, InnerTailwindComponentOtherProps<E>>;
    <E extends IntrinsicElementsKeys>(Element: E): TemplateFunction<E>;
    <E extends React.ComponentType<any>>(Element: E): TemplateFunction<E>;
}
export declare type IntrinsicElementsTemplateFunctionsMap = {
    [key in IntrinsicElementsKeys]: TemplateFunction<key>;
};
declare const tw: TemplateFunctionFactory & IntrinsicElementsTemplateFunctionsMap;
export default tw;
